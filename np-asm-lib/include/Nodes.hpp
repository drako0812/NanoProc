#pragma once

namespace npasm::parser {

    /// The base node for the abstract syntax tree generated by the Parser
    class ASTNode {
    public:
        using sptr = std::shared_ptr<ASTNode>;

        inline ASTNode() = default;
        inline virtual ~ASTNode() { }
    };

    /// A generic base class for all derived ASTNode types
    ///
    /// \tparam T The derived ASTNode type
    template <class T>
    class BaseASTNode : public ASTNode {
    public:
        using sptr = std::shared_ptr<T>;

        inline BaseASTNode() : ASTNode() { }
        inline virtual ~BaseASTNode() { }
    };

    /// Represents a label (`label_name:`)
    class Label : public BaseASTNode<Label> {
    public:

        /// The string representing the label name
        std::string Value;

        inline Label() : BaseASTNode() { }
        inline Label(std::string const& ident) :
            BaseASTNode(), Value{ident} {}

        inline virtual ~Label() { }
    };

    /// Represents a mnemonic (`MOVE`, `PUSH`, `JUMP`, etc.)
    class Mnemonic : public BaseASTNode<Mnemonic> {
    public:
        std::string Value;

        inline Mnemonic() : BaseASTNode() { }
        inline Mnemonic(std::string const& value) :
            BaseASTNode(), Value{value} {}

        inline virtual ~Mnemonic() { }
    };

    /// Represents a word size (`word` or `byte`)
    class WordSize : public BaseASTNode<WordSize> {
    public:
        std::string Value;

        inline WordSize() : BaseASTNode() { }
        inline WordSize(std::string const& value) :
            BaseASTNode(), Value{value} {}

        inline virtual ~WordSize() { }
    };

    /// Represents a full instruction (`MOVE $ACC, 123`)
    class Instruction : public BaseASTNode<Instruction> {
    public:
        Mnemonic::sptr Mnemonic;
        WordSize::sptr WordSize;

        inline Instruction() : BaseASTNode() { }
        inline Instruction(Mnemonic::sptr mnemonic, WordSize::sptr word_size) :
            BaseASTNode(), Mnemonic{mnemonic}, WordSize{word_size} { }
        inline virtual ~Instruction() { }
    };

    /// Represents an instruction that takes no arguments (`NOP` or `POP word`)
    class NoArgumentInstruction : public BaseASTNode<NoArgumentInstruction>, public Instruction {
    public:
        using sptr = BaseASTNode<NoArgumentInstruction>::sptr;

        inline NoArgumentInstruction() : Instruction(), BaseASTNode<NoArgumentInstruction>() { }
        inline NoArgumentInstruction(Mnemonic::sptr mnemonic, WordSize::sptr word_size) :
            Instruction(mnemonic, word_size), BaseASTNode<NoArgumentInstruction>() {}
        inline virtual ~NoArgumentInstruction() { }
    };

    /// Represents some argument to an instruction.
    class Argument : public BaseASTNode<Argument> {
    public:
        inline Argument() : BaseASTNode() { }
        inline virtual ~Argument() { }
    };

    /// Represents a pointer argument (`[123]`, `[$SP]`, `[some_label]`, `[X+123]`)
    class PointerArgument : public BaseASTNode<PointerArgument>, public Argument {
    public:
        using sptr = BaseASTNode<PointerArgument>::sptr;
        Argument::sptr SubArgument;

        inline PointerArgument() : Argument(), BaseASTNode<PointerArgument>() { }
        inline PointerArgument(Argument::sptr sub_arg) :
            Argument(), BaseASTNode<PointerArgument>(),
            SubArgument{sub_arg} {}
        inline virtual ~PointerArgument() { }
    };

    /// Represents a X-indexed argument (`X+123`, `X-$ACC`)
    class XIndexArgument : public BaseASTNode<XIndexArgument>, public Argument {
    public:
        using sptr = BaseASTNode<XIndexArgument>::sptr;
        bool Plus;
        Argument::sptr SubArgument;

        inline XIndexArgument() : Argument(), BaseASTNode<XIndexArgument>() { }
        inline XIndexArgument(bool plus, Argument::sptr sub_arg) :
            Argument(), BaseASTNode<XIndexArgument>(),
            Plus{plus}, SubArgument{sub_arg} {}
        inline virtual ~XIndexArgument() { }
    };

    /// Represents a Y-indexed argument (`Y+123`, `Y-$ACC`)
    class YIndexArgument : public BaseASTNode<YIndexArgument>, public Argument {
    public:
        using sptr = BaseASTNode<YIndexArgument>::sptr;
        bool Plus;
        Argument::sptr SubArgument;

        inline YIndexArgument() : Argument(), BaseASTNode<YIndexArgument>() { }
        inline YIndexArgument(bool plus, Argument::sptr sub_arg) :
            Argument(), BaseASTNode<YIndexArgument>(),
            Plus{plus}, SubArgument{sub_arg} {}
        inline virtual ~YIndexArgument() { }
    };

    /// Represents a register argument (`$ACC`, `$Al`, `$Blh`)
    class RegisterArgument : public BaseASTNode<RegisterArgument>, public Argument {
    public:
        using sptr = BaseASTNode<RegisterArgument>::sptr;
        std::string Value;

        inline RegisterArgument() : Argument(), BaseASTNode<RegisterArgument>() { }
        inline RegisterArgument(std::string const& value) :
            Argument(), BaseASTNode<RegisterArgument>(),
            Value{value} {}
        inline virtual ~RegisterArgument() { }
    };

    /// Represents an immediate argument (`label_name`, `123`, `-0xFE`, `'a'`)
    class ImmediateArgument : public BaseASTNode<ImmediateArgument>, public Argument {
    public:
        using sptr = BaseASTNode<ImmediateArgument>::sptr;
        inline ImmediateArgument() : Argument(), BaseASTNode<ImmediateArgument>() { }
        inline virtual ~ImmediateArgument() { }
    };

    /// Represents an integer argument (`123`, `0765`, `0xFEDC`, `-0b0101`, `'a'`)
    class IntegerArgument : public BaseASTNode<IntegerArgument>, public ImmediateArgument {
    public:
        using sptr = BaseASTNode<IntegerArgument>::sptr;
        std::int64_t Value;

        inline IntegerArgument() : ImmediateArgument(), BaseASTNode<IntegerArgument>() { }
        inline IntegerArgument(std::int64_t value) :
            ImmediateArgument(), BaseASTNode<IntegerArgument>(),
            Value{value} {}
        inline virtual ~IntegerArgument() { }
    };

    /// Represents an identifier argument (`label_name`)
    class IdentifierArgument : public BaseASTNode<IdentifierArgument>, public ImmediateArgument {
    public:
        using sptr = BaseASTNode<IdentifierArgument>::sptr;
        std::string Value;

        inline IdentifierArgument() : ImmediateArgument(), BaseASTNode<IdentifierArgument>() { }
        inline IdentifierArgument(std::string const& value) :
            ImmediateArgument(), BaseASTNode<IdentifierArgument>(),
            Value{value} {}
        inline virtual ~IdentifierArgument() { }
    };

    /// Represents a single-argument instruction (`PUSH word $Ah`)
    class OneArgumentInstruction : public BaseASTNode<OneArgumentInstruction>, public Instruction {
    public:
        using sptr = BaseASTNode<OneArgumentInstruction>::sptr;
        Argument::sptr Argument;

        inline OneArgumentInstruction() : Instruction(), BaseASTNode<OneArgumentInstruction>() { }
        inline OneArgumentInstruction(Mnemonic::sptr mnemonic, WordSize::sptr word_size, Argument::sptr arg) :
            Instruction(mnemonic, word_size), BaseASTNode<OneArgumentInstruction>(),
            Argument{arg} { }
        inline virtual ~OneArgumentInstruction() { }
    };

    /// Represents a two-argument instruction (`MOVE $ACC, 123`)
    class TwoArgumentInstruction : public BaseASTNode<TwoArgumentInstruction>, public Instruction {
    public:
        using sptr = BaseASTNode<TwoArgumentInstruction>::sptr;
        Argument::sptr Argument1;
        Argument::sptr Argument2;

        inline TwoArgumentInstruction() : Instruction(), BaseASTNode<TwoArgumentInstruction>() { }
        inline TwoArgumentInstruction(Mnemonic::sptr mnemonic, WordSize::sptr word_size, Argument::sptr arg1, Argument::sptr arg2) :
            Instruction(mnemonic, word_size), BaseASTNode<TwoArgumentInstruction>(),
            Argument1{arg1}, Argument2{arg2} { }
        inline virtual ~TwoArgumentInstruction() { }
    };

    /// Represents a comment (`; This is a comment`)
    class Comment : public BaseASTNode<Comment> {
    public:
        std::string Value;

        inline Comment() : BaseASTNode() { }
        inline Comment(std::string const& value) :
            BaseASTNode(), Value{value} { }
        inline virtual ~Comment() { }
    };

    /// Represents a full line of code (`label_name: MOVE word $Al, [X+123] ; Comment`)
    class Line : public BaseASTNode<Line> {
    public:
        Label::sptr Label;
        Instruction::sptr Instruction;
        Comment::sptr Comment;

        inline Line() : BaseASTNode() { }
        inline Line(Label::sptr label, Instruction::sptr instruction, Comment::sptr comment) :
            Label{label}, Instruction{instruction}, Comment{comment} {}
        inline virtual ~Line() { }
    };

    /// Represents a full program
    class Program : public BaseASTNode<Program> {
    public:
        std::vector<Line::sptr> Lines;

        inline Program() :
            BaseASTNode(), Lines{} {}
        inline virtual ~Program() { }
    };

}
